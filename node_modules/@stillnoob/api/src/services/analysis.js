import { db } from '../db/client.js';
import { fightPerformance, fights, bosses } from '../db/schema.js';
import { eq, and, gte, desc, sql } from 'drizzle-orm';
import { CONSUMABLE_PATTERNS, BUFF_PATTERNS, CONSUMABLE_WEIGHTS, SCORE_WEIGHTS, SCORE_TIERS } from '@stillnoob/shared';

/**
 * Process extended fight data from WCL and store per-fight performance snapshots.
 * Called during report import for each fight.
 *
 * @param {number} storedFightId - DB fight ID (fights table)
 * @param {number} fightDurationMs - Fight duration in milliseconds
 * @param {object} basicStats - { damage, healing, damageTaken, deaths }
 * @param {object} extendedStats - { casts, buffs, interrupts, dispels }
 * @param {object} charMap - { "lowercaseName": characterId }
 * @returns {number} Number of records inserted
 */
export async function processExtendedFightData(storedFightId, fightDurationMs, basicStats, extendedStats, charMap) {
  const fightDurationSec = fightDurationMs / 1000;
  const playerData = {};

  const ensurePlayer = (name) => {
    if (!playerData[name]) {
      playerData[name] = {
        damageDone: 0, healingDone: 0, damageTaken: 0, deaths: 0,
        healthPotions: 0, healthstones: 0, combatPotions: 0,
        flaskUptime: 0, foodBuff: false, augmentRune: false,
        interrupts: 0, dispels: 0,
      };
    }
  };

  // Basic stats
  for (const e of basicStats.damage || []) { ensurePlayer(e.name); playerData[e.name].damageDone = e.total || 0; }
  for (const e of basicStats.healing || []) { ensurePlayer(e.name); playerData[e.name].healingDone = e.total || 0; }
  for (const e of basicStats.damageTaken || []) { ensurePlayer(e.name); playerData[e.name].damageTaken = e.total || 0; }
  for (const e of basicStats.deaths || []) { ensurePlayer(e.name); playerData[e.name].deaths = e.total || 0; }

  // Casts — scan for consumable usage
  for (const entry of extendedStats.casts || []) {
    if (!entry.name) continue;
    ensurePlayer(entry.name);
    const abilities = entry.abilities || entry.entries || [];
    for (const ability of abilities) {
      const name = ability.name || '';
      if (CONSUMABLE_PATTERNS.healthPotion.test(name)) {
        playerData[entry.name].healthPotions += (ability.total || ability.hitCount || 1);
      }
      if (CONSUMABLE_PATTERNS.healthstone.test(name)) {
        playerData[entry.name].healthstones += (ability.total || ability.hitCount || 1);
      }
      if (CONSUMABLE_PATTERNS.combatPotion.test(name)) {
        playerData[entry.name].combatPotions += (ability.total || ability.hitCount || 1);
      }
    }
  }

  // Buffs — flask, food, augment rune
  for (const entry of extendedStats.buffs || []) {
    if (!entry.name) continue;
    ensurePlayer(entry.name);
    const auras = entry.abilities || entry.entries || [];
    for (const aura of auras) {
      const name = aura.name || '';
      const uptime = aura.uptime || 0;
      if (BUFF_PATTERNS.flask.test(name)) {
        playerData[entry.name].flaskUptime = Math.max(playerData[entry.name].flaskUptime, uptime);
      }
      if (BUFF_PATTERNS.food.test(name)) {
        playerData[entry.name].foodBuff = true;
      }
      if (BUFF_PATTERNS.augmentRune.test(name)) {
        playerData[entry.name].augmentRune = true;
      }
    }
  }

  // Interrupts & Dispels
  for (const entry of extendedStats.interrupts || []) {
    if (!entry.name) continue;
    ensurePlayer(entry.name);
    playerData[entry.name].interrupts = entry.total || 0;
  }
  for (const entry of extendedStats.dispels || []) {
    if (!entry.name) continue;
    ensurePlayer(entry.name);
    playerData[entry.name].dispels = entry.total || 0;
  }

  // Calculate raid medians
  const allDps = [];
  const allDtps = [];
  for (const data of Object.values(playerData)) {
    if (data.damageDone > 0 && fightDurationSec > 0) allDps.push(data.damageDone / fightDurationSec);
    if (data.damageTaken > 0 && fightDurationSec > 0) allDtps.push(data.damageTaken / fightDurationSec);
  }
  allDps.sort((a, b) => a - b);
  allDtps.sort((a, b) => a - b);
  const medianDps = allDps.length > 0 ? allDps[Math.floor(allDps.length / 2)] : 0;
  const medianDtps = allDtps.length > 0 ? allDtps[Math.floor(allDtps.length / 2)] : 0;

  // Insert per-player records (only for registered characters)
  let inserted = 0;
  for (const [playerName, data] of Object.entries(playerData)) {
    const characterId = charMap[playerName.toLowerCase()];
    if (!characterId) continue;

    const dps = fightDurationSec > 0 ? data.damageDone / fightDurationSec : 0;
    const hps = fightDurationSec > 0 ? data.healingDone / fightDurationSec : 0;
    const dtps = fightDurationSec > 0 ? data.damageTaken / fightDurationSec : 0;

    try {
      await db.insert(fightPerformance).values({
        fightId: storedFightId,
        characterId,
        damageDone: data.damageDone,
        healingDone: data.healingDone,
        damageTaken: data.damageTaken,
        deaths: data.deaths,
        dps, hps, dtps,
        healthPotions: data.healthPotions,
        healthstones: data.healthstones,
        combatPotions: data.combatPotions,
        flaskUptimePct: data.flaskUptime,
        foodBuffActive: data.foodBuff,
        augmentRuneActive: data.augmentRune,
        interrupts: data.interrupts,
        dispels: data.dispels,
        raidMedianDps: medianDps,
        raidMedianDtps: medianDtps,
      }).onConflictDoNothing();
      inserted++;
    } catch (err) {
      if (!err.message?.includes('UNIQUE')) {
        console.warn(`Failed to insert fight perf for ${playerName}:`, err.message);
      }
    }
  }

  return inserted;
}

/**
 * Get detailed performance analysis for a character.
 * Returns summary, boss breakdown, weekly trends, recent fights, and recommendations.
 */
export async function getCharacterPerformance(characterId, options = {}) {
  const { weeks = 8, bossId, difficulty } = options;
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - (weeks * 7));
  const cutoffDate = cutoff.toISOString().split('T')[0];

  // Build dynamic WHERE conditions for raw SQL
  let where = 'WHERE fp.character_id = ? AND f.start_time >= ?';
  const params = [characterId, cutoff.getTime()];
  if (bossId) { where += ' AND f.encounter_id = ?'; params.push(bossId); }
  if (difficulty) { where += ' AND f.difficulty = ?'; params.push(difficulty); }

  // Use raw SQL via the libsql client for complex aggregate queries
  const { client } = await import('../db/client.js');

  // Summary stats
  const summaryResult = await client.execute({
    sql: `SELECT
      COUNT(*) as totalFights,
      ROUND(AVG(fp.dps), 1) as avgDps,
      ROUND(AVG(fp.hps), 1) as avgHps,
      ROUND(AVG(fp.dtps), 1) as avgDtps,
      SUM(fp.deaths) as totalDeaths,
      ROUND(CAST(SUM(fp.deaths) AS REAL) / MAX(COUNT(*), 1), 2) as deathRate,
      ROUND(AVG(fp.flask_uptime_pct), 1) as avgFlaskUptime,
      ROUND(AVG(CASE WHEN fp.food_buff_active THEN 1 ELSE 0 END) * 100, 1) as foodRate,
      ROUND(AVG(CASE WHEN fp.augment_rune_active THEN 1 ELSE 0 END) * 100, 1) as augmentRate,
      ROUND(AVG(fp.interrupts), 1) as avgInterrupts,
      ROUND(AVG(fp.dispels), 1) as avgDispels,
      ROUND(AVG(CASE WHEN fp.raid_median_dps > 0 THEN (fp.dps / fp.raid_median_dps) * 100 ELSE 100 END), 1) as dpsVsMedianPct,
      ROUND(CAST(SUM(CASE WHEN fp.health_potions > 0 THEN 1 ELSE 0 END) AS REAL) / MAX(COUNT(*), 1) * 100, 1) as healthPotionRate,
      ROUND(CAST(SUM(CASE WHEN fp.healthstones > 0 THEN 1 ELSE 0 END) AS REAL) / MAX(COUNT(*), 1) * 100, 1) as healthstoneRate,
      ROUND(CAST(SUM(CASE WHEN fp.combat_potions > 0 THEN 1 ELSE 0 END) AS REAL) / MAX(COUNT(*), 1) * 100, 1) as combatPotionRate
    FROM fight_performance fp
    JOIN fights f ON f.id = fp.fight_id
    ${where}`,
    args: params,
  });

  const summary = summaryResult.rows[0] || {};
  const totalFights = Number(summary.totalFights) || 0;

  // Calculate consumable score
  const healthPotionRate = Number(summary.healthPotionRate) || 0;
  const healthstoneRate = Number(summary.healthstoneRate) || 0;
  const combatPotionRate = Number(summary.combatPotionRate) || 0;
  const avgFlaskUptime = Number(summary.avgFlaskUptime) || 0;
  const foodRate = Number(summary.foodRate) || 0;
  const augmentRate = Number(summary.augmentRate) || 0;

  const consumableScore = Math.round(
    healthPotionRate * CONSUMABLE_WEIGHTS.healthPotion +
    healthstoneRate * CONSUMABLE_WEIGHTS.healthstone +
    combatPotionRate * CONSUMABLE_WEIGHTS.combatPotion +
    avgFlaskUptime * CONSUMABLE_WEIGHTS.flask +
    foodRate * CONSUMABLE_WEIGHTS.food +
    augmentRate * CONSUMABLE_WEIGHTS.augmentRune
  );

  // Boss breakdown
  const bossResult = await client.execute({
    sql: `SELECT
      f.encounter_id as bossId,
      f.boss_name as bossName,
      f.difficulty,
      COUNT(*) as fights,
      SUM(fp.deaths) as deaths,
      ROUND(CAST(SUM(fp.deaths) AS REAL) / MAX(COUNT(*), 1), 2) as deathRate,
      ROUND(AVG(fp.dps), 1) as avgDps,
      ROUND(MAX(fp.dps), 1) as bestDps,
      ROUND(AVG(fp.dtps), 1) as avgDtps,
      ROUND(CAST(SUM(CASE WHEN fp.health_potions > 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100, 1) as healthPotionRate,
      ROUND(CAST(SUM(CASE WHEN fp.healthstones > 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100, 1) as healthstoneRate,
      ROUND(CAST(SUM(CASE WHEN fp.combat_potions > 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100, 1) as combatPotionRate,
      ROUND(AVG(fp.interrupts), 1) as interruptsPerFight,
      ROUND(AVG(fp.dispels), 1) as dispelsPerFight,
      ROUND(AVG(CASE WHEN fp.raid_median_dps > 0 THEN (fp.dps / fp.raid_median_dps) * 100 ELSE 100 END), 1) as dpsVsMedian
    FROM fight_performance fp
    JOIN fights f ON f.id = fp.fight_id
    ${where}
    GROUP BY f.encounter_id, f.difficulty
    ORDER BY f.difficulty DESC, COUNT(*) DESC`,
    args: params,
  });

  const bossBreakdown = bossResult.rows.map(r => ({
    bossId: Number(r.bossId),
    bossName: r.bossName,
    difficulty: r.difficulty,
    fights: Number(r.fights),
    deaths: Number(r.deaths),
    deathRate: Number(r.deathRate),
    avgDps: Number(r.avgDps),
    bestDps: Number(r.bestDps),
    avgDtps: Number(r.avgDtps),
    healthPotionRate: Number(r.healthPotionRate),
    healthstoneRate: Number(r.healthstoneRate),
    combatPotionRate: Number(r.combatPotionRate),
    interruptsPerFight: Number(r.interruptsPerFight),
    dispelsPerFight: Number(r.dispelsPerFight),
    dpsVsMedian: Number(r.dpsVsMedian),
  }));

  // Weekly trends (Thursday-Wednesday weeks)
  const trendsResult = await client.execute({
    sql: `SELECT
      date(datetime(f.start_time / 1000, 'unixepoch'), '-' || ((CAST(strftime('%w', datetime(f.start_time / 1000, 'unixepoch')) AS INTEGER) + 3) % 7) || ' days') as weekStart,
      COUNT(*) as fights,
      ROUND(AVG(fp.dps), 1) as avgDps,
      ROUND(AVG(fp.hps), 1) as avgHps,
      ROUND(CAST(SUM(fp.deaths) AS REAL) / MAX(COUNT(*), 1), 2) as avgDeaths,
      ROUND(AVG(fp.dtps), 1) as avgDtps,
      ROUND(
        CAST(SUM(CASE WHEN fp.health_potions > 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 20 +
        CAST(SUM(CASE WHEN fp.healthstones > 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 15 +
        CAST(SUM(CASE WHEN fp.combat_potions > 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 25 +
        AVG(fp.flask_uptime_pct) * 0.25 +
        AVG(CASE WHEN fp.food_buff_active THEN 1 ELSE 0 END) * 10 +
        AVG(CASE WHEN fp.augment_rune_active THEN 1 ELSE 0 END) * 5,
      1) as consumableScore
    FROM fight_performance fp
    JOIN fights f ON f.id = fp.fight_id
    ${where}
    GROUP BY weekStart
    ORDER BY weekStart ASC`,
    args: params,
  });

  const weeklyTrends = trendsResult.rows.map(r => ({
    weekStart: r.weekStart,
    fights: Number(r.fights),
    avgDps: Number(r.avgDps),
    avgHps: Number(r.avgHps),
    avgDeaths: Number(r.avgDeaths),
    avgDtps: Number(r.avgDtps),
    consumableScore: Number(r.consumableScore),
  }));

  // Add week-over-week changes
  for (let i = 1; i < weeklyTrends.length; i++) {
    const prev = weeklyTrends[i - 1];
    const curr = weeklyTrends[i];
    curr.dpsChange = prev.avgDps > 0 ? Math.round((curr.avgDps - prev.avgDps) / prev.avgDps * 100) : 0;
    curr.deathChange = prev.avgDeaths > 0 ? Math.round((curr.avgDeaths - prev.avgDeaths) / prev.avgDeaths * 100) : 0;
  }

  // Recent fights
  const recentResult = await client.execute({
    sql: `SELECT
      datetime(f.start_time / 1000, 'unixepoch') as date,
      f.boss_name as boss,
      f.difficulty,
      ROUND(fp.dps, 1) as dps,
      fp.deaths,
      fp.damage_taken as damageTaken,
      fp.health_potions as potions,
      fp.healthstones,
      fp.combat_potions as combatPotions,
      fp.interrupts,
      fp.dispels,
      ROUND(CASE WHEN fp.raid_median_dps > 0 THEN (fp.dps / fp.raid_median_dps) * 100 ELSE 100 END, 1) as dpsVsMedian
    FROM fight_performance fp
    JOIN fights f ON f.id = fp.fight_id
    ${where}
    ORDER BY f.start_time DESC, fp.id DESC
    LIMIT 20`,
    args: params,
  });

  const recentFights = recentResult.rows.map(r => ({
    date: r.date,
    boss: r.boss,
    difficulty: r.difficulty,
    dps: Number(r.dps),
    deaths: Number(r.deaths),
    damageTaken: Number(r.damageTaken),
    potions: Number(r.potions),
    healthstones: Number(r.healthstones),
    combatPotions: Number(r.combatPotions),
    interrupts: Number(r.interrupts),
    dispels: Number(r.dispels),
    dpsVsMedian: Number(r.dpsVsMedian),
  }));

  // Generate recommendations
  const summaryData = {
    totalFights,
    avgDps: Number(summary.avgDps) || 0,
    avgHps: Number(summary.avgHps) || 0,
    avgDtps: Number(summary.avgDtps) || 0,
    deathRate: Number(summary.deathRate) || 0,
    consumableScore,
    dpsVsMedianPct: Number(summary.dpsVsMedianPct) || 100,
    healthPotionRate,
    healthstoneRate,
    combatPotionRate,
    avgFlaskUptime,
    foodRate,
    augmentRate,
    avgInterrupts: Number(summary.avgInterrupts) || 0,
    avgDispels: Number(summary.avgDispels) || 0,
  };

  const recommendations = generateRecommendations({ summary: summaryData, bossBreakdown, weeklyTrends });
  const score = calculateStillNoobScore(summaryData, bossBreakdown);

  return {
    summary: summaryData,
    score,
    bossBreakdown,
    weeklyTrends,
    recentFights,
    recommendations,
  };
}

/**
 * Calculate StillNoob Score — proprietary 0-100 metric.
 * Weighted composite of performance, survival, preparation, utility, consistency.
 */
function calculateStillNoobScore(summary, bossBreakdown) {
  if (!summary || summary.totalFights === 0) {
    return { total: 0, tier: SCORE_TIERS[0], breakdown: { performance: 0, survival: 0, preparation: 0, utility: 0, consistency: 0 } };
  }

  // Performance (35%): DPS vs raid median — 100% median = 50 points, 130%+ = 100
  const dpsRatio = summary.dpsVsMedianPct || 100;
  const performanceRaw = Math.min(100, Math.max(0, (dpsRatio - 70) * (100 / 60))); // 70%→0, 130%→100

  // Survival (25%): death rate inverted — 0 deaths = 100, 0.5+ = 0
  const survivalRaw = Math.min(100, Math.max(0, (1 - summary.deathRate / 0.5) * 100));

  // Preparation (20%): consumable score (already 0-100)
  const preparationRaw = Math.min(100, summary.consumableScore || 0);

  // Utility (10%): interrupts + dispels normalized
  const avgUtil = (summary.avgInterrupts || 0) + (summary.avgDispels || 0);
  const utilityRaw = Math.min(100, avgUtil * 25); // 4+ combined = 100

  // Consistency (10%): inverse of DPS variance across bosses
  let consistencyRaw = 100;
  if (bossBreakdown.length >= 3) {
    const dpsValues = bossBreakdown.filter(b => b.avgDps > 0).map(b => b.avgDps);
    if (dpsValues.length >= 3) {
      const max = Math.max(...dpsValues);
      const min = Math.min(...dpsValues);
      const variance = max > 0 ? ((max - min) / max) * 100 : 0;
      consistencyRaw = Math.max(0, 100 - variance);
    }
  }

  const breakdown = {
    performance: Math.round(performanceRaw),
    survival: Math.round(survivalRaw),
    preparation: Math.round(preparationRaw),
    utility: Math.round(utilityRaw),
    consistency: Math.round(consistencyRaw),
  };

  const total = Math.round(
    breakdown.performance * SCORE_WEIGHTS.performance +
    breakdown.survival * SCORE_WEIGHTS.survival +
    breakdown.preparation * SCORE_WEIGHTS.preparation +
    breakdown.utility * SCORE_WEIGHTS.utility +
    breakdown.consistency * SCORE_WEIGHTS.consistency
  );

  const tier = SCORE_TIERS.find(t => total >= t.min && total <= t.max) || SCORE_TIERS[0];

  return { total, tier, breakdown };
}

/**
 * Recommendation engine — generates actionable tips based on performance data.
 * Returns i18n keys with data for frontend rendering.
 */
function generateRecommendations({ summary, bossBreakdown, weeklyTrends }) {
  const tips = [];
  if (!summary || summary.totalFights === 0) return tips;

  // ── Survivability ──
  if (summary.deathRate > 0.4) {
    tips.push({
      category: 'survivability', key: 'high_death_rate', severity: 'critical',
      data: { rate: summary.deathRate.toFixed(2) },
    });
  } else if (summary.deathRate <= 0.2) {
    tips.push({
      category: 'survivability', key: 'good_survival', severity: 'positive',
      data: { rate: summary.deathRate.toFixed(2) },
    });
  }

  // Boss-specific high damage
  for (const boss of bossBreakdown) {
    if (boss.avgDtps > 0 && boss.fights >= 3) {
      const dtpsRatio = boss.avgDtps / (summary.avgDtps || 1);
      if (dtpsRatio > 1.4) {
        tips.push({
          category: 'survivability', key: 'high_damage_boss', severity: 'warning',
          data: { boss: boss.bossName, difficulty: boss.difficulty, dtps: Math.round(boss.avgDtps), avgDtps: Math.round(summary.avgDtps) },
        });
      }
    }
  }

  // Trend-based survival
  if (weeklyTrends.length >= 4) {
    const recent = weeklyTrends.slice(-2);
    const older = weeklyTrends.slice(-4, -2);
    const recentDeaths = recent.reduce((s, w) => s + w.avgDeaths, 0) / recent.length;
    const olderDeaths = older.reduce((s, w) => s + w.avgDeaths, 0) / older.length;
    if (olderDeaths > 0) {
      const change = Math.round(((recentDeaths - olderDeaths) / olderDeaths) * 100);
      if (change <= -20) {
        tips.push({ category: 'survivability', key: 'improving_survival', severity: 'positive', data: { change: Math.abs(change) } });
      } else if (change >= 20) {
        tips.push({ category: 'survivability', key: 'worsening_survival', severity: 'warning', data: { change } });
      }
    }
  }

  // ── Consumables ──
  if (summary.healthPotionRate < 50) {
    tips.push({ category: 'consumables', key: 'low_health_potion', severity: 'warning', data: { rate: Math.round(summary.healthPotionRate) } });
  }
  if (summary.healthstoneRate < 30) {
    tips.push({ category: 'consumables', key: 'no_healthstone', severity: 'info', data: { rate: Math.round(summary.healthstoneRate) } });
  }
  if (summary.combatPotionRate < 70) {
    tips.push({ category: 'consumables', key: 'low_combat_potion', severity: 'warning', data: { rate: Math.round(summary.combatPotionRate) } });
  }
  if (summary.avgFlaskUptime < 90) {
    tips.push({ category: 'consumables', key: 'low_flask', severity: 'warning', data: { uptime: Math.round(summary.avgFlaskUptime) } });
  }
  if (summary.foodRate < 80) {
    tips.push({ category: 'consumables', key: 'no_food', severity: 'info', data: { rate: Math.round(summary.foodRate) } });
  }
  if (summary.healthPotionRate >= 60 && summary.combatPotionRate >= 70 && summary.avgFlaskUptime >= 90 && summary.foodRate >= 80) {
    tips.push({ category: 'consumables', key: 'good_consumables', severity: 'positive', data: {} });
  }

  // ── Performance ──
  if (weeklyTrends.length >= 4) {
    const recent = weeklyTrends.slice(-2);
    const older = weeklyTrends.slice(-4, -2);
    const recentDps = recent.reduce((s, w) => s + w.avgDps, 0) / recent.length;
    const olderDps = older.reduce((s, w) => s + w.avgDps, 0) / older.length;
    if (olderDps > 0) {
      const change = Math.round(((recentDps - olderDps) / olderDps) * 100);
      if (change >= 10) {
        tips.push({ category: 'performance', key: 'dps_improving', severity: 'positive', data: { change } });
      } else if (change <= -10) {
        tips.push({ category: 'performance', key: 'dps_declining', severity: 'warning', data: { change: Math.abs(change) } });
      }
    }
  }

  if (summary.dpsVsMedianPct < 80) {
    tips.push({ category: 'performance', key: 'below_raid_median', severity: 'critical', data: { pct: Math.round(summary.dpsVsMedianPct) } });
  } else if (summary.dpsVsMedianPct > 110) {
    tips.push({ category: 'performance', key: 'above_raid_median', severity: 'positive', data: { pct: Math.round(summary.dpsVsMedianPct - 100) } });
  }

  // DPS consistency
  if (bossBreakdown.length >= 3) {
    const dpsValues = bossBreakdown.filter(b => b.avgDps > 0).map(b => b.avgDps);
    if (dpsValues.length >= 3) {
      const min = Math.min(...dpsValues);
      const max = Math.max(...dpsValues);
      const variance = max > 0 ? ((max - min) / max) * 100 : 0;
      if (variance > 40) {
        tips.push({ category: 'performance', key: 'inconsistent_dps', severity: 'info', data: { variance: Math.round(variance) } });
      }
    }
  }

  // ── Utility ──
  if (summary.avgInterrupts < 1 && summary.totalFights >= 5) {
    tips.push({ category: 'utility', key: 'low_interrupts', severity: 'info', data: { avg: summary.avgInterrupts.toFixed(1) } });
  } else if (summary.avgInterrupts >= 3) {
    tips.push({ category: 'utility', key: 'good_interrupts', severity: 'positive', data: { avg: summary.avgInterrupts.toFixed(1) } });
  }

  return tips;
}
